#!/usr/bin/env python
# In project imports
import srp_md
from srp_md import learn, sense, srp_md_log

# Ros and Python imports
import rospy
import logging
import random
import pickle
import os
import argparse
# import sys
# import random
# import csv
# from datetime import datetime
# import time
# import multiprocessing
# import Queue

# Define file path
script_path = os.path.dirname(os.path.realpath(__file__))
data_folder = os.path.realpath(script_path + '/../../data')
demo_folder = os.path.realpath(script_path + '/../../data/demos')

# Get a logger
logger = logging.getLogger('srp_md')
logger.setLevel(logging.DEBUG)

# Initialize variables
# OBJECTS = ["cracker", "gelatin", "meat", "mustard", "soup", "sugar", "bleach"]
OBJECTS = ["cracker", "meat", "mustard", "soup", "sugar"]
RELATIONS = ["disjoint", "proximity", "on", "support"]

# Objects used in experiments
grocery_experiment_objs =["cracker", "meat", "mustard", "soup", "sugar"]
# Grocery experiment list
grocery_experiment_demo_objs =[
    ["cracker", "cracker", "sugar", "soup", "soup", "meat"],
    ["cracker", "sugar", "sugar", "meat", "meat", "meat"],
    ["cracker", "sugar", "soup", "soup", "soup", "mustard"],
    ["cracker", "cracker", "sugar", "sugar", "mustard", "mustard", "soup"],
    ["cracker", "sugar", "sugar", "sugar", "mustard", "meat", "meat"],
    ["cracker", "cracker", "sugar", "soup", "soup", "meat", "meat"],
    ["cracker", "sugar", "meat", "meat", "meat", "soup", "soup"],
    ["cracker", "sugar", "sugar", "soup", "meat", "soup"],
    ["cracker", "sugar", "soup", "soup", "meat", "meat"],
    ["cracker", "cracker", "sugar", "mustard", "mustard", "mustard", "mustard"],
    ["cracker", "cracker", "sugar", "meat", "meat", "soup"],
    ["cracker", "cracker", "cracker", "sugar", "mustard", "mustard", "mustard"],
    ["cracker", "sugar", "sugar", "sugar", "meat", "meat", "soup"],
    ["cracker", "cracker", "sugar", "meat", "meat", "meat"],
    ["sugar", "sugar", "sugar", "soup", "soup", "soup"],
    ["cracker", "cracker", "cracker", "soup", "soup", "soup", "soup"],
    ["cracker", "cracker", "meat", "meat", "meat", "soup", "mustard"],
    ["cracker", "sugar", "sugar", "soup", "meat", "meat", "mustard"],
    ["cracker", "sugar", "soup", "soup", "meat", "mustard", "mustard"],
    ["cracker", "sugar", "sugar", "soup", "soup", "mustard"]
]

def generate_demo_scenes(demo_num, demo_objs_nums, noise_num, obj_list=None):
    """
    Hardcode Examples
    """
    scene_graphs = []

    # For number of demos needed, do:
    for i in range(demo_num):

        # Pick objects randomly, based on number of demos (which is also chosen randomly from recommended list)
        objs = [srp_md.Object(name="table", id_num=0, uuid=0, assignment={'class': "table"})]
        uuid = 1
        for j in range(random.choice(demo_objs_nums)):
            name = random.choice(OBJECTS)
            if obj_list is not None:
                name = obj_list[i][j]
            objs.append(srp_md.Object(name=name + "_" + str(uuid), id_num=uuid, uuid=uuid, assignment={'class': name}))
            uuid += 1

        scene_graph = srp_md.SceneGraph(objs)
        # print(scene_graph.get_obj_names())

        # Update all relations based on general grocery goal
        print "\nObjects List: ", scene_graph.get_obj_names(), "\n"
        for relation in scene_graph.relations:
            user_input = None

            # Make the user give inputs
            print "For ", relation.obj1, " and ", relation.obj2
            print "Relation list: ", RELATIONS
            user_input = raw_input("Specify relation for relations in the list by their index: \n")
            while int(user_input) not in range(len(RELATIONS)):
                user_input = raw_input("Wrong value! Choose again... \n")
            relation.value = RELATIONS[int(user_input)]
            print "You chose: ", relation.value, "\n"

        # Add noise to the relation
        if i < noise_num:
            relation = random.choice(scene_graph.relations)
            relation.value = RELATIONS[random.randint(0, len(RELATIONS) - 1)]

        scene_graphs.append(scene_graph)

    return scene_graphs

def generate_demo_scenes_from_list(objs_list):
    scene_graphs = []
    for objs in objs_list:
        print('New scene graph with {}'.format(objs))
        sg_objs = [srp_md.Object(name='{}_{}'.format(obj, uuid),
            id_num=uuid, uuid=uuid, assignment={'class': obj}) for uuid, obj in enumerate(objs)]
        sg_objs.append(
            srp_md.Object(name='table', id_num=len(sg_objs), uuid=len(sg_objs), assignment={'class': 'table'}))
        scene_graph = srp_md.SceneGraph(sg_objs)
        index = 0
        while index < len(scene_graph.relations):
            while True:
                try:
                    rel = scene_graph.relations[index]
                    rel.value = RELATIONS[int(raw_input(
                        'X(    {},    {}    )\n  Choices: {} (>={}: go back):\n'.format(
                        rel.obj1, rel.obj2, list(enumerate(RELATIONS)), len(RELATIONS))))]
                    index += 1
                    break
                except IndexError:
                    print('Go back to previous relation\n')
                    index = max(index - 1, 0)
                except ValueError:
                    print('Input an integer')
            print('{}({}, {})\n'.format(rel.value, rel.obj1, rel.obj2))
        scene_graphs.append(scene_graph)
        _save_graphs(scene_graphs, 'save_state.pickle', 'save_state', '{}/graphs'.format(data_folder))
        print('Saved scene with {}'.format(objs))

    return scene_graphs


def generate_init_scenes(init_num, num_objs, obj_list=None):
    """
    Hardcode Examples
    """
    if obj_list is None:
        obj_list = OBJECTS

    scene_graphs = []

    # For number of demos needed, do:
    for i in range(init_num):

        # Pick objects randomly, based on number of demos (which is also chosen randomly from recommended list)
        objs = [srp_md.Object(name="table", id_num=0, uuid=0, assignment={'class': "table"})]
        uuid = 1
        for _ in range(random.choice(num_objs)):
            name = random.choice(obj_list)
            objs.append(srp_md.Object(name=name + "_" + str(uuid), id_num=uuid, uuid=uuid, assignment={'class': name}))
            uuid += 1

        scene_graph = srp_md.SceneGraph(objs)

        # print "\nObjects List: ", scene_graph.get_obj_names(), "\n"

        # Make all relations disjoint
        for relation in scene_graph.relations:
            relation.value = 'proximity'

        scene_graphs.append(scene_graph)

    return scene_graphs

def _save_graphs(graphs, pickle_name, file_prefix, dirname):
    pickle_file = os.path.join(dirname, pickle_name)
    pickle.dump(graphs, open(pickle_file, 'wb'))
    for i, demo in enumerate(graphs):
        demo.to_all(os.path.join(dirname, "{}_{}".format(file_prefix, i)), draw_disjoint=False, flip_relations=True)

def save_graphs(demo_graphs, test_graphs, generated_graphs, dirname):
    _save_graphs(demo_graphs, 'data.pickle', 'demo', dirname)
    _save_graphs(test_graphs, 'test.pickle', 'test', dirname)
    _save_graphs(generated_graphs, 'generated.pickle', 'generated', dirname)

def load_demos(dirname):
    file_names = [os.path.join(dirname, file) for file in os.listdir(dirname)
                  if os.path.isfile(os.path.join(dirname, file)) and os.path.splitext(file)[-1] == '.sg']
    # Sort by number, note this expects the name to follow this pattern '<name>_#.sg'
    file_names.sort(key=lambda name: int(name[name.rfind('_')+1:name.rfind('.sg')]))
    demo_graphs = [srp_md.SceneGraph.from_file(file_name) for file_name in file_names]
    return demo_graphs

def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')

def parse_args():
    """
    Parse input arguments
    """
    parser = argparse.ArgumentParser(description='Run an simulated experiment')

    # Main arguments, used for paper's experiments
    parser.add_argument('--factor_learner', help='Specify the factor learner', default='decision_tree', type=str,
                        choices=learn.FACTOR_LEARNERS.keys())
    parser.add_argument('--use_consistency', help='Choose to use consistency prior', default=True, type=str2bool)
    parser.add_argument('--use_no_float', help='Choose to use no float prior', default=True, type=str2bool)
    parser.add_argument('--use_cardinality', help='Choose to use learned cardinality', default=True, type=str2bool)
    parser.add_argument('--demo_graphs_dir', type=str, help='Folder with all .sg files'
                        ' if not provided then demos will be manually typed in on command prompt')
    parser.add_argument('--test_graphs_dir', type=str, help='Folder of test scenes as .sg files'
                        ' if not provided then random initial scenes will be generated')
    parser.add_argument('--output_dir', type=str, help='To write the demo, test, and generated .sg files',
                        default='{}/graphs'.format(data_folder))

    # Extra useful arguments
    parser.add_argument('--log_level', help='Set the logging level', default=logging.DEBUG, type=int,
                        choices=[logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL])

    args = parser.parse_args()

    # Handle input file dirs
    for path in [args.demo_graphs_dir, args.test_graphs_dir]:
        if path is not None:
            if not os.path.isdir(path):
                raise(IOError('{} not a valid path'.format(path)))
    # Handle output file dirs
    if args.output_dir is not None:
        if not os.path.isdir(args.output_dir):
            os.mkdir(args.output_dir)

    return args

def main():
    args = parse_args()
    logger.setLevel(args.log_level)
    logger.info('Running experiment with these args: {}'.format(args))

    # Setup ROS
    rospy.init_node('simulate_experiment', anonymous=True)
    logger.info('Started the simulate_experiment node...')
    # init_folder = os.path.realpath(script_path + '/../../data/inits')

    if args.demo_graphs_dir is not None:
        demo_graphs = load_demos(args.demo_graphs_dir)
    else:
        # Simulate goal scenegraphs
        # demo_num, demo_objs_nums, noise_num = 20, [6], 0
        demo_graphs = generate_demo_scenes_from_list(grocery_experiment_demo_objs)
        # demo_graphs = generate_demo_scenes(demo_num, demo_objs_nums, noise_num)
        # demo_graphs = generate_demo_scenes(demo_num, demo_objs_nums, noise_num, [["cracker", "gelatin", "meat", "soup", "sugar"], ["cracker", "gelatin", "gelatin", "mustard", "bleach"]])
    logger.info('Generated {} demo graphs with {} noises'.format(len(demo_graphs), 0))

    # Simulate initial scenegraphs
    init_num, init_objs_nums = 3, [2]
    test_graphs = generate_init_scenes(init_num, list(range(3, 5)), grocery_experiment_objs)
    # test_graphs = generate_init_scenes(init_num, init_objs_nums, [["cracker", "gelatin"]])
    logger.info('Generated {} initial scenes'.format(init_num))

    # Setup SRP_MD object
    srp = srp_md.SrpMd(sensor="dope_sensor", learner="factor_graph_learner", goal_generator="factor_graph_goal_generator")
    srp.update_learner_config(factor_learner=args.factor_learner)
    srp.update_goal_generator_config(use_consistency=args.use_consistency, use_no_float=args.use_no_float,
                                     use_cardinality=args.use_cardinality)
    srp.set_scenes(demo_graphs, test_graphs)
    logger.info('Initialized SrpMd object with scenes')

    # Learn from current data
    srp.learn()
    logger.info('Learned!')

    # Generate goals from learned factors
    srp.generate_goal()
    logger.info('Generated goals')

    # Save the graphs
    if args.output_dir is not None:
        save_graphs(demo_graphs, test_graphs, srp._goal_instances, args.output_dir)

if __name__ == '__main__':
    logger.info('Simulation Experiment starting up... #BOLD')
    try:
        main()
    finally:
        logger.info('Simulation Experiment stopping... #BOLD')
