#!/usr/bin/env python
from __future__ import print_function
from builtins import range
from builtins import input
# In project imports
import srp_md
from srp_md import learn, sense, srp_md_log, utils

# Ros and Python imports
import rospy
import logging
import random
import pickle
import os
import argparse
import itertools
# import sys
# import random
import csv
# from datetime import datetime
import time
# import multiprocessing
# import Queue

# Define file path
script_path = os.path.dirname(os.path.realpath(__file__))
data_folder = os.path.realpath(script_path + '/../../data')
demo_folder = os.path.realpath(script_path + '/../../data/demos')

# Get a logger
logger = logging.getLogger('srp_md')
logger.setLevel(logging.DEBUG)

# Initialize variables
# OBJECTS = ["cracker", "gelatin", "meat", "mustard", "soup", "sugar", "bleach"]
OBJECTS = ["cracker", "meat", "mustard", "soup", "sugar"]
RELATIONS = ["disjoint", "proximity", "on", "support"]

# Objects used in experiments
grocery_experiment_objs = ["cracker", "meat", "mustard", "soup", "sugar"]
# Grocery experiment list
grocery_experiment_demo_objs = [
    ["cracker", "cracker", "sugar", "soup", "soup", "meat"],
    ["cracker", "sugar", "sugar", "meat", "meat", "meat"],
    ["cracker", "sugar", "soup", "soup", "soup", "mustard"],
    ["cracker", "cracker", "sugar", "sugar", "mustard", "mustard", "soup"],
    ["cracker", "sugar", "sugar", "sugar", "mustard", "meat", "meat"],
    ["cracker", "cracker", "sugar", "soup", "soup", "meat", "meat"],
    ["cracker", "sugar", "meat", "meat", "meat", "soup", "soup"],
    ["cracker", "sugar", "sugar", "soup", "meat", "soup"],
    ["cracker", "sugar", "soup", "soup", "meat", "meat"],
    ["cracker", "cracker", "sugar", "mustard", "mustard", "mustard", "mustard"],
    ["cracker", "cracker", "sugar", "meat", "meat", "soup"],
    ["cracker", "cracker", "cracker", "sugar", "mustard", "mustard", "mustard"],
    ["cracker", "sugar", "sugar", "sugar", "meat", "meat", "soup"],
    ["cracker", "cracker", "sugar", "meat", "meat", "meat"],
    ["sugar", "sugar", "sugar", "soup", "soup", "soup"],
    ["cracker", "cracker", "cracker", "soup", "soup", "soup", "soup"],
    ["cracker", "cracker", "meat", "meat", "meat", "soup", "mustard"],
    ["cracker", "sugar", "sugar", "soup", "meat", "meat", "mustard"],
    ["cracker", "sugar", "soup", "soup", "meat", "mustard", "mustard"],
    ["cracker", "sugar", "sugar", "soup", "soup", "mustard"]
]


def generate_demo_scenes(demo_num, demo_objs_nums, noise_num, obj_list=None):
    """
    Hardcode Examples
    """
    scene_graphs = []

    # For number of demos needed, do:
    for i in range(demo_num):

        # Pick objects randomly, based on number of demos (which is also chosen randomly from recommended list)
        objs = [srp_md.Object(name="table", id_num=0, uuid=0, assignment={'class': "table"})]
        uuid = 1
        for j in range(random.choice(demo_objs_nums)):
            name = random.choice(OBJECTS)
            if obj_list is not None:
                name = obj_list[i][j]
            objs.append(srp_md.Object(name=name + "_" + str(uuid), id_num=uuid, uuid=uuid, assignment={'class': name}))
            uuid += 1

        scene_graph = srp_md.SceneGraph(objs)
        # print(scene_graph.get_obj_names())

        # Update all relations based on general grocery goal
        print("\nObjects List: ", scene_graph.get_obj_names(), "\n")
        for relation in scene_graph.relations:
            user_input = None

            # Make the user give inputs
            print("For ", relation.obj1, " and ", relation.obj2)
            print("Relation list: ", RELATIONS)
            user_input = input("Specify relation for relations in the list by their index: \n")
            while int(user_input) not in range(len(RELATIONS)):
                user_input = input("Wrong value! Choose again... \n")
            relation.value = RELATIONS[int(user_input)]
            print("You chose: ", relation.value, "\n")

        # Add noise to the relation
        if i < noise_num:
            relation = random.choice(scene_graph.relations)
            relation.value = RELATIONS[random.randint(0, len(RELATIONS) - 1)]

        scene_graphs.append(scene_graph)

    return scene_graphs


def generate_demo_scenes_from_list(objs_list):
    scene_graphs = []
    for objs in objs_list:
        print('New scene graph with {}'.format(objs))
        sg_objs = [srp_md.Object(name='{}_{}'.format(obj, uuid),
                   id_num=uuid, uuid=uuid, assignment={'class': obj}) for uuid, obj in enumerate(objs)]
        sg_objs.append(
            srp_md.Object(name='table', id_num=len(sg_objs), uuid=len(sg_objs), assignment={'class': 'table'}))
        scene_graph = srp_md.SceneGraph(sg_objs)
        index = 0
        while index < len(scene_graph.relations):
            while True:
                try:
                    rel = scene_graph.relations[index]
                    rel.value = RELATIONS[int(input(
                        'X(    {},    {}    )\n  Choices: {} (>={}: go back):\n'.format(
                         rel.obj1, rel.obj2, list(enumerate(RELATIONS)), len(RELATIONS))))]
                    index += 1
                    break
                except IndexError:
                    print('Go back to previous relation\n')
                    index = max(index - 1, 0)
                except ValueError:
                    print('Input an integer')
            print('{}({}, {})\n'.format(rel.value, rel.obj1, rel.obj2))
        scene_graphs.append(scene_graph)
        _save_graphs(scene_graphs, 'save_state.pickle', 'save_state', '{}/graphs'.format(data_folder))
        print('Saved scene with {}'.format(objs))

    return scene_graphs


def generate_init_scenes(num_test_scenes, num_objs, obj_list=None):
    """
    Hardcode Examples
    """
    if obj_list is None:
        obj_list = OBJECTS

    scene_graphs = []

    # For number of demos needed, do:
    for i in range(num_test_scenes):

        # Pick objects randomly, based on number of demos (which is also chosen randomly from recommended list)
        objs = [srp_md.Object(name="table", id_num=0, uuid=0, assignment={'class': "table"})]
        uuid = 1
        for _ in range(random.choice(num_objs)):
            name = random.choice(obj_list)
            objs.append(srp_md.Object(name=name + "_" + str(uuid), id_num=uuid, uuid=uuid, assignment={'class': name}))
            uuid += 1

        scene_graph = srp_md.SceneGraph(objs)

        # print "\nObjects List: ", scene_graph.get_obj_names(), "\n"

        # Make all relations disjoint
        for relation in scene_graph.relations:
            relation.value = 'proximity'

        scene_graphs.append(scene_graph)

    return scene_graphs


def _save_graphs(graphs, pickle_name, file_prefix, dirname):
    pickle_file = os.path.join(dirname, pickle_name)
    pickle.dump(graphs, open(pickle_file, 'wb'))
    for i, graph in enumerate(graphs):
        if graph is None:
            continue
        graph.to_all(os.path.join(dirname, "{}_{}".format(file_prefix, i)), draw_disjoint=False, flip_relations=True)


def save_graphs(demo_graphs, test_graphs, generated_graphs, dirname):
    _save_graphs(demo_graphs, 'data.pickle', 'demo', dirname)
    _save_graphs(test_graphs, 'test.pickle', 'test', dirname)
    _save_graphs(generated_graphs, 'generated.pickle', 'generated', dirname)


def load_demos(dirname):
    file_names = [os.path.join(dirname, file) for file in os.listdir(dirname)
                  if os.path.isfile(os.path.join(dirname, file)) and os.path.splitext(file)[-1] == '.sg']
    # Sort by number, note this expects the name to follow this pattern '<name>_#.sg'
    file_names.sort(key=lambda name: int(name[name.rfind('_')+1:name.rfind('.sg')]))
    demo_graphs = [srp_md.SceneGraph.from_file(file_name) for file_name in file_names]
    return demo_graphs


def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')


def evaluate_goal(scene):
    # Ensure a scene was generated
    if scene is None:
        return (False, 'failed to generate any goal')

    # Ensure everything is on the table
    table = [obj for obj in scene.objs if obj.name.find('table') != -1][0]
    for obj in filter(lambda obj: not obj == table, scene.objs):
        rel = scene.get_rel_by_objs(obj, table)
        if rel.obj1 == table:
            if rel.value != 'support':
                return (False, 'table does not support an object')
        else:
            if rel.value != 'on':
                return (False, 'an object is not on a table')

    # Ensure all boxes are stacked by size
    boxes = [obj for obj in scene.objs if obj.assignment['class'] == 'cracker' or obj.assignment['class'] == 'sugar']
    for objs in itertools.combinations(boxes, 2):
        rel = scene.get_rel_by_objs(objs[0], objs[1])
        # Both objects the same class
        if objs[0].assignment['class'] == objs[1].assignment['class']:
            if rel.value != 'support' and rel.value != 'on':
                return (False, 'boxes not stacked')
        # Different class
        else:
            if rel.obj1.assignment['class'] == 'cracker':
                if rel.value != 'support':
                    return (False, 'cracker must support sugar')
            else:
                if rel.value != 'on':
                    return (False, 'sugar must be on cracker')

    # Ensure that the bottom box is next to all cans
    # Find the bottom box
    bot_box = None
    for box in boxes:
        num_on = 0
        for obj in filter(lambda obj: not obj == box, scene.objs):
            rel = scene.get_rel_by_objs(box, obj)
            if rel.obj1 == box:
                if rel.value == 'on':
                    num_on += 1
            elif rel.value == 'support':
                num_on += 1
            if num_on > 1:
                break
        if num_on == 1:
            bot_box = box
            break
    # Ensure all cans next to bot_box
    if bot_box is not None:
        for obj in filter(lambda obj: obj.assignment['class'] == 'meat' or obj.assignment['class'] == 'soup',
                          scene.objs):
            rel = scene.get_rel_by_objs(obj, bot_box)
            if rel.value != 'proximity':
                return (False, 'cans not proximity to bottom box')

    # Ensure mustards are grouped together but disjoint with all but the table
    for mustard in filter(lambda obj: obj.assignment['class'] == 'mustard', scene.objs):
        for obj in filter(lambda obj: not (obj == table or obj == mustard), scene.objs):
            rel = scene.get_rel_by_objs(mustard, obj)
            # Proximity or disjoint to other mustard
            if obj.assignment['class'] == 'mustard':
                if rel.value != 'proximity' and rel.value != 'disjoint':
                    return (False, 'mustard not proximity or disjoint with other mustard')
            elif rel.value != 'disjoint':
                return (False, 'mustard not disjoint with non-mustard object')

    return (True, 'success')


def powerset(iterable):
    s = list(iterable)
    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))


def random_combinations(iterable, r, num_combos):
    """Random selection from itertools.combinations(iterable, r)"""
    pool = tuple(iterable)
    n = len(pool)
    for _ in range(num_combos):
        yield tuple(pool[index] for index in sorted(random.sample(range(n), r)))


def random_powerset(iterable, num_to_sample):
    """!
    @brief      Randomly sample from the powerset in order of set size

    @param      iterable       The iterable
    @param      num_to_sample  The number to sample from each set size,
                               if num_to_sample > len(iterable)! / (r! (n - r)!) then sample all combinations of size r

    @return     Generator of the randomly selected elements of the powerset in order of set size
    """
    s = list(iterable)
    n = len(s)
    chain = itertools.chain()
    for r in range(n + 1):
        if utils.ncr(n, r) <= num_to_sample:
            chain = itertools.chain(chain, itertools.combinations(s, r))
        else:
            chain = itertools.chain(chain, random_combinations(s, r, num_to_sample))
    return chain


def len_random_powerset(len_iterable, num_to_sample):
    size = 0
    for r in range(len_iterable + 1):
        ncr = utils.ncr(len_iterable, r)
        if ncr <= num_to_sample:
            size += ncr
        else:
            size += num_to_sample
    return size


def secs_to_str(secs):
    secs = int(secs)
    weeks = secs // 604800
    secs = secs % 604800
    days = secs // 86400
    secs = secs % 86400
    hours = secs // 3600
    secs = secs % 3600
    miniutes = secs // 60
    secs = secs % 60
    return '{}w {}d {}h {}m {}s'.format(weeks, days, hours, miniutes, secs)


def parse_args():
    """
    Parse input arguments
    """
    parser = argparse.ArgumentParser(description='Run an simulated experiment')

    # Main arguments, used for paper's experiments
    parser.add_argument('--factor_learner', help='Specify the factor learner', default='decision_tree', type=str,
                        choices=learn.FACTOR_LEARNERS.keys())
    parser.add_argument('--use_consistency', help='Choose to use consistency prior', default=True, type=str2bool)
    parser.add_argument('--use_no_float', help='Choose to use no float prior', default=True, type=str2bool)
    parser.add_argument('--use_cardinality', help='Choose to use learned cardinality', default=True, type=str2bool)
    parser.add_argument('--demo_graphs_dir', type=str, help='Folder with all .sg files'
                        ' if not provided then demos will be manually typed in on command prompt')
    parser.add_argument('--test_graphs_dir', type=str, help='Folder of test scenes as .sg files'
                        ' if not provided then random initial scenes will be generated')
    parser.add_argument('--num_test_scenes', type=int, default=10, help='Number of test scenes to use for every set'
                        ' of demonstrations')
    parser.add_argument('--num_samples', type=int, default=20, help='Number of random samples to to take from each '
                        'possible cardinality of demonstrations')
    parser.add_argument('--max_num_test_objs', type=int, default=4, help='Maximum number of objects in test '
                        'scene')
    parser.add_argument('--min_num_test_objs', type=int, default=3, help='Minimum number of objects in test '
                        'scene')
    parser.add_argument('output_dir', type=str,
                        help='To write the demo, test, and generated .sg files and results.csv',
                        default='{}/graphs'.format(data_folder))

    # Extra useful arguments
    parser.add_argument('--log_level', help='Set the logging level', default=logging.DEBUG, type=int,
                        choices=[logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL])

    args = parser.parse_args()

    # Handle input file dirs
    for path in [args.demo_graphs_dir, args.test_graphs_dir]:
        if path is not None:
            if not os.path.isdir(path):
                raise(IOError('{} not a valid path'.format(path)))
    # Handle output file dirs
    if args.output_dir is not None:
        if not os.path.isdir(args.output_dir):
            os.mkdir(args.output_dir)

    return args


def main():
    args = parse_args()
    logger.setLevel(args.log_level)
    logger.info('Running experiment with these args: {}'.format(args))

    # Setup ROS
    rospy.init_node('simulate_experiment', anonymous=True)
    logger.info('Started the simulate_experiment node...')
    # init_folder = os.path.realpath(script_path + '/../../data/inits')

    if args.demo_graphs_dir is not None:
        demo_graphs = load_demos(args.demo_graphs_dir)
    else:
        # Simulate goal scenegraphs
        # demo_num, demo_objs_nums, noise_num = 20, [6], 0
        demo_graphs = generate_demo_scenes_from_list(grocery_experiment_demo_objs)
        # demo_graphs = generate_demo_scenes(demo_num, demo_objs_nums, noise_num)
        # demo_graphs = generate_demo_scenes(demo_num, demo_objs_nums, noise_num,
        #                                    [["cracker", "gelatin", "meat", "soup", "sugar"],
        #                                     ["cracker", "gelatin", "gelatin", "mustard", "bleach"]])
    logger.info('Generated {} demo graphs with {} noises'.format(len(demo_graphs), 0))

    # Setup SRP_MD object
    srp = srp_md.SrpMd(sensor="dope_sensor",
                       learner="factor_graph_learner",
                       goal_generator="factor_graph_goal_generator")
    srp.update_learner_config(factor_learner=args.factor_learner)
    srp.update_goal_generator_config(use_consistency=args.use_consistency, use_no_float=args.use_no_float,
                                     use_cardinality=args.use_cardinality)

    # Pickup where you left off
    global_index = -1
    with open(args.output_dir + '/results.csv', 'r+') as results_file:
        csv_reader = csv.reader(results_file)
        for row in csv_reader:
            global_index = int(row[0])
    global_index += 1

    args.num_test_scenes = 10
    args.num_samples = 20
    last_trial = global_index / args.num_test_scenes
    logger.info('Previously completed {} trials, resuming at {}'.format(last_trial - 1, last_trial))
    start_time = time.time()
    avg_time = 0
    num_trials = len_random_powerset(len(demo_graphs), args.num_samples) - 1
    for trial_num, demos in enumerate(filter(lambda demos: len(demos) != 0,
                                      random_powerset(demo_graphs, args.num_samples))):
        # Skip until at resuming point
        if trial_num < last_trial:
            continue

        # Simulate initial scenegraphs
        test_graphs = generate_init_scenes(args.num_test_scenes,
                                           list(range(args.min_num_test_objs, args.max_num_test_objs + 1)),
                                           grocery_experiment_objs)
        # test_graphs = generate_init_scenes(args.num_test_scenes, init_objs_nums, [["cracker", "gelatin"]])
        logger.info('Generated {} initial scenes'.format(len(test_graphs)))

        srp.set_scenes(demos, test_graphs)
        logger.info('Initialized SrpMd object with {} demos'.format(len(demos)))

        # Learn from current data
        srp.learn()
        logger.info('Learned!')

        # Generate goals from learned factors
        # try rospy.service.ServiceException
        srp.generate_goal()
        logger.info('Generated goals')

        # Generate results.csv
        with open(args.output_dir + '/results.csv', 'a+') as global_results_file:
            global_results_writer = csv.writer(global_results_file)
            for index, (goal, test_graph) in enumerate(zip(srp._goal_instances, test_graphs)):
                result, reason = evaluate_goal(goal)
                logger.info('Generated goal {} {} {}'.format(index,
                                                             'succeded' if result else 'failed',
                                                             'because ' + reason if not result else ''))
                global_results_writer.writerow([index + global_index, len(demos), result, reason,
                                                test_graph.num_objs()])
        global_index += len(srp._goal_instances)

        # Timing info
        now = time.time()
        diff = now - start_time
        start_time = now
        avg_time = (diff + (trial_num - last_trial) * avg_time) / (trial_num - last_trial + 1)
        print('----------------------')
        logger.info('avg_time: {}'.format(avg_time))
        logger.info('Trial: {} ({} remaining)'.format(trial_num, num_trials - trial_num - 1))
        logger.info('Estimated time remaining: {}'.format(secs_to_str((num_trials - trial_num - 1) * avg_time)))
        logger.info('Percent completed: {}%'.format(100.0 * (trial_num + 1) / num_trials))
        print('----------------------')


if __name__ == '__main__':
    logger.info('Simulation Experiment starting up... #BOLD')
    try:
        main()
    finally:
        logger.info('Simulation Experiment stopping... #BOLD')
