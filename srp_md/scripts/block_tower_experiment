#!/usr/bin/env python
# In project imports
import srp_md
from srp_md import learn, sense, goal, srp_md_log

# Ros imports
import rospy

# Python imports
import logging
import argparse
import sys
import signal
import random
import csv
from datetime import datetime

# Get a logger
logger = logging.getLogger('srp_md')
logger.setLevel(logging.INFO)


def str2bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')


def parse_args():
    """
    Parse input arguments
    """
    parser = argparse.ArgumentParser(description='Run block tower experiment')
    parser.add_argument('--num_demos', help='Specify the number of goal demos to give', default=100, type=int)
    parser.add_argument('--num_goals', help='Specify the number of goals to generate', default=100, type=int)
    parser.add_argument('--percent_noise', help='Specify the percentage of noisy examples', default=0.0, type=float)
    parser.add_argument('--factor_learner', help='Specify the factor learner', default='joint_frequency', type=str,
                        choices=learn.FACTOR_LEARNERS.keys())
    parser.add_argument('--use_consistency', help='Choose to use consistency prior', default=True, type=str2bool)
    parser.add_argument('--use_commonsense', help='Choose to use consistency prior', default=False, type=str2bool)
    parser.add_argument('--log_level', help='Set the logging level', default=logging.DEBUG, type=int,
                        choices=[logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL])
    parser.add_argument('--min_num_objs', help='The min number of objects to use in sensor', default=3, type=int)
    parser.add_argument('--max_num_objs', help='The max number of objects to use in sensor', default=10, type=int)
    parser.add_argument('--num_objs', help='The exact number of objects to use in sensor, overrides min and max',
                        default=None, type=int)
    parser.add_argument('-f', '--factors_to_learn', type=int, action='append',
                        help='A factor designated by number of objects in the factor multiple -f can be specified')
    parser.add_argument('--file', type=argparse.FileType('ab'), help='output csv file', default='out.csv')
    parser.add_argument('--experiment', type=str, help='Which experiment to run', default='single',
                        choices=['single', 'num_demos'])
    args = parser.parse_args()
    if args.num_objs is not None:
        args.min_num_objs = args.num_objs
        args.max_num_objs = args.num_objs
    if args.factors_to_learn is None:
        args.factors_to_learn = [2]
    return args


def main():
    # Get arguments
    args = parse_args()
    logger.setLevel(args.log_level)
    logger.info('Running block tower experiment with these args: {}'.format(args))

    # Setup ros
    rospy.init_node('block_tower_experiment', anonymous=True)

    # Writ results to a file
    with args.file:
        # Setup csv file
        file_writer = csv.writer(args.file)
        if args.experiment == 'single':
            single_experiment(args.min_num_objs,
                              args.max_num_objs,
                              args.factor_learner,
                              args.factors_to_learn,
                              args.use_consistency,
                              args.use_commonsense,
                              args.num_demos,
                              args.percent_noise,
                              args.num_goals,
                              file_writer,
                              args.num_objs)
        elif args.experiment == 'num_demos':
            for num_demos in xrange(1, 26):
                single_experiment(args.min_num_objs,
                                  args.max_num_objs,
                                  args.factor_learner,
                                  args.factors_to_learn,
                                  args.use_consistency,
                                  args.use_commonsense,
                                  num_demos,
                                  args.percent_noise,
                                  args.num_goals,
                                  file_writer,
                                  args.num_objs)


def single_experiment(min_num_objs,
                      max_num_objs,
                      factor_learner,
                      factors_to_learn,
                      use_consistency,
                      use_commonsense,
                      num_demos,
                      percent_noise,
                      num_goals,
                      file_writer,
                      num_objs):
    # Define the srp
    srp = srp_md.SrpMd(learner='factor_graph_learner', sensor='block_tower2_sensor',
                       goal_generator='factor_graph_goal_generator')
    srp.update_sensor_config(demo_type='only_goal', min_num_objs=min_num_objs, max_num_objs=max_num_objs)
    srp.update_learner_config(factor_learner=factor_learner, factors_to_learn=factors_to_learn)
    srp.use_priors(use_consistency, use_commonsense)

    # Experiment
    # init
    num_correct = 0
    num_noise = 0
    # Get demos
    while srp.get_num_demos() < num_demos:
        try:
            demo_type = 'only_goal'
            if random.random() < percent_noise:
                demo_type = 'only_not_goal'
            srp.update_sensor_config(demo_type=demo_type)
            srp.process_data()
            if demo_type == 'only_not_goal':
                num_noise += 1
        except ValueError as e:
            logger.warn('Failed to get a demo: {}'.format(e))
    logger.info('Completed {} demos with {} bad examples'.format(srp.get_num_demos(), num_noise))
    # Learn
    srp.learn()
    logger.info('Learned')
    # Generate goals from random observations
    srp.demo_type = 'random'
    num_gen_goals = 0
    while num_gen_goals < num_goals:
        try:
            num_gen_goals += 1
            srp.generate_goal()
        except (ValueError, rospy.ServiceException) as e:
            logger.warn('Failed to generate goal trying again: ' + str(e))
            continue
        try:
            if srp.evaluate_goal():
                num_correct += 1
        except ValueError as e:
            logger.warn('Failed to evaluate goal must be a bad goal...' + str(e))
    logger.info('Number of examples {}\n\t'
                'Number of bad examples {}\n\t'
                'Generated and evaluated {} goals with {}%% correct'.format(
                    num_demos, num_noise, num_gen_goals, 100.0 * num_correct / num_gen_goals))

    # file_writer.writerow(['time', 'factors', 'consistency', 'commonsense', 'factor_learner', 'min_num_objs',
    #                       'max_num_objs', 'num_objs', 'demos', 'bad_demos', 'goals', 'correct'])
    file_writer.writerow(
        [datetime.now(),
         factors_to_learn[0],
         use_consistency,
         use_commonsense,
         factor_learner,
         min_num_objs,
         max_num_objs,
         num_objs,
         num_demos,
         num_noise,
         num_goals,
         num_correct])


if __name__ == '__main__':
    logger.info('Block tower experiment starting up... #BOLD')
    sys.argv = rospy.myargv()
    try:
        main()
    finally:
        logger.info('Block tower experiment stopping... #BOLD')
